
from __future__ import annotations
from django.utils import timezone
from django.db.models.query import QuerySet
from django.db.models import Q
from rules.models import Rule
from typing import Dict, List
from uuid import uuid4
import yaml
import re


categories_mapping: dict = {
    1: "process_creation",
    2: "file_change",
    3: "network_connection",
    4: "sysmon_status",
    5: "process_termination",
    6: "driver_load",
    7: "image_load",
    8: "create_remote_thread",
    9: "raw_access_thread",
    10: "process_access",
    11: "file_event",
    12: "registry_add",
    13: "registry_delete",
    14: "registry_set",
    15: "create_stream_hash",
    17: "pipe_created",
    19: "wmi_event",
    22: "dns_query",
    23: "file_delete",
    24: "clipboard_change",
    25: "process_tampering",
    26: "file_delete_detected",
    27: "file_block_executable",
    28: "file_block_shredding",
    29: "file_executable_detected",
    255: "sysmon_error",
    4104: "ps_script"
}

class RuleItem(Rule):
    
    def to_rule_filter(self) -> Dict:
        detection = self.detection.copy()
        detection["evaluation"] = self.create_eval_expression()
        # Pop the condition key
        detection.pop("condition")
        return {"id": self.id, "logsource": self.logsource, "detection": detection}
    

    def create_eval_expression(self) -> str:
        """
        Build an expression that can be evaluated against an event.
        The expression will be used by the filter engine.
        E.g.: selection and not 1 of filter_* -> func(selection) and not any_of(func(filter_1), func(filter_2))
        """
        condition = self.detection.get("condition", "")
        block_names = [key for key in self.detection.keys() if key != "condition"]
        eval_expr = ""
        condition = condition.replace('(', ' ( ')
        condition = condition.replace(')', ' ) ')

        for token in re.split(r'\s+', condition):
            if not token:
                continue
            elif token in ('and', 'or', 'not', 'all', 'of', '1', 'of'):
                eval_expr += token + ' '
                continue
            elif token in ('(', ')'):
                eval_expr += token
                continue
            
            if '*' not in token:
                expr_token = f"FilterEngine.match_block(rule['detection']['{token}'], event)"
            else:
                func_calls = [f"FilterEngine.match_block(rule['detection']['{block_name}'], event)"
                              for block_name in block_names if block_name.startswith(token.strip('*'))]
                expr_token = f"({', '.join(func_calls)})"
            eval_expr += expr_token + ' '

        eval_expr = eval_expr.replace('all of ', 'all_of')
        eval_expr = eval_expr.replace('1 of ', 'any_of')
        eval_expr = eval_expr.replace('\\', '\\\\')
        eval_expr = 'FilterEngine.match_logsource(rule["logsource"], event) and ' + eval_expr
        eval_expr = eval_expr.strip()
        return eval_expr
    
    
    def to_dict(self) -> Dict:
        try:
            rule_item = RuleItem.objects.get(id=self.id)
        except RuleItem.DoesNotExist:
            rule_item = None
        finally:
            if rule_item:
                time_created = rule_item.date
            else:
                time_created =timezone.now()
            return {
                "title": self.title,
                "id": self.id,
                "related": self.related,
                "status": self.status,
                "description": self.description,
                "references": self.references,
                "author": self.author,
                "tags": self.tags,
                "logsource": self.logsource,
                "detection": self.detection,
                "falsepositives": self.falsepositives,
                "level": self.level,
                "date": time_created,
                "modified": timezone.now(),
                "is_active": self.is_active,
            }
    

    def to_yaml(self) -> str:
        return yaml.dump(self.to_dict(), sort_keys=False)
    

    def to_sample_yaml(self) -> str:
        rule_dict = self.to_dict()
        rule_dict["id"] = "<auto-generated>"
        rule_dict["date"] = "<auto-generated>"
        rule_dict["modified"] = "<auto-generated>"
        rule_dict["is_active"] = False
        return yaml.dump(rule_dict, sort_keys=False)
    
    

    @staticmethod
    def is_valid_rule(rule: Dict) -> bool:
        if not isinstance(rule, dict):
            return False
        # check for required fields
        title = rule.get("title")
        if not title or not isinstance(title, str):
            return False
        rule_id = rule.get("id")
        if not rule_id or not isinstance(rule_id, str):
            return False
        related = rule.get("related")
        if related and not isinstance(related, list):
            return False
        status = rule.get("status")
        if not status or not isinstance(status, str):
            return False
        description = rule.get("description")
        if not description or not isinstance(description, str):
            return False
        references = rule.get("references")
        if references and not isinstance(references, list):
            return False
        author = rule.get("author")
        if not author or not isinstance(author, str):
            return False
        # date = rule.get("date")
        # if date or not isinstance(date, str):
        #     return False
        # modified = rule.get("modified")
        # if modified and not isinstance(modified, str):
        #     return False
        tags = rule.get("tags")
        if tags and not isinstance(tags, list):
            return False
        logsource = rule.get("logsource")
        if not logsource or not isinstance(logsource, dict):
            return False
        product = logsource.get("product")
        if not product or not isinstance(product, str):
            return False
        category = logsource.get("category")
        if not category or not isinstance(category, str):
            return False
        detection = rule.get("detection")
        if not detection or not isinstance(detection, dict):
            return False
        condition = detection.get("condition")
        if not condition or not isinstance(condition, str):
            return False
        falsepositives = rule.get("falsepositives")
        if falsepositives and not isinstance(falsepositives, list):
            return False
        level = rule.get("level")
        if not level or not isinstance(level, str):
            return False
        return True
    

    @staticmethod
    def from_dict(rule: Dict) -> RuleItem:
        if not RuleItem.is_valid_rule(rule):
            return None
        try:
            rule_item = RuleItem.objects.get(id=rule["id"])
        except RuleItem.DoesNotExist:
            rule_item = None
        finally:
            if rule_item:
                time_created = rule_item.date
            else:
                time_created = timezone.now()
            return RuleItem(
                title=rule["title"],
                id=rule["id"],
                related=rule.get("related", []),
                status=rule["status"],
                description=rule["description"],
                references=rule.get("references", []),
                author=rule["author"],
                date=time_created,
                modified=timezone.now(),
                tags=rule.get("tags", []),
                logsource=rule["logsource"],
                detection=rule["detection"],
                falsepositives=rule.get("falsepositives", []),
                level=rule["level"],
                is_active=rule.get("is_active", False)
            )

    

    @staticmethod
    def from_yaml(yaml_str: str) -> RuleItem:
        try:
            rule = yaml.safe_load(yaml_str)
            return RuleItem.from_dict(rule)
        except yaml.YAMLError as e:
            return None


    @staticmethod
    def get_field(rule: Dict, *keys) -> str:
        for key in keys:
            if not isinstance(rule, dict):
                return None
            rule = rule.get(key)
        return rule
    

    @staticmethod
    def get_expected_category(event_id: int) -> str:
        return categories_mapping.get(event_id, 'unknown')
    

    @staticmethod
    def generate_id() -> str:
        return str(uuid4())
    

    @staticmethod
    def search_rules(search_str: str) -> QuerySet[RuleItem]:
        '''
        Search for rules based on the search string.
        Format: field1="value1" AND field2~"value2" OR ...
        '''
        print("Search string:", search_str)
        if not search_str:
            return RuleItem.objects.all()

        single_query = r'([\w\d]+)\s*([~=<>])\s*"([^"]*)"'
        pattern = single_query + r'|\b(AND|OR)\b'
        def split_pattern_string(input_string, pattern):
            # The pattern to match individual conditions and logical operators
            matches = re.findall(pattern, input_string)
            result = []
            for match in matches:
                if match[3]:
                    result.append(match[3])
                else:
                    result.append(f'{match[0]}{match[1]}"{match[2]}"')
            return result
        
        query = []
        for token in split_pattern_string(search_str, pattern):
            if token == 'AND':
                query.append('&')
            elif token == 'OR':
                query.append('|')
            else:
                field, operator, value = re.match(single_query, token).groups()
                if operator == '=':
                    query.append('Q({}="{}")'.format(field, value))
                elif operator == '~':
                    query.append('Q({}__icontains="{}")'.format(field, value))
                elif operator == '>':
                    query.append('Q({}__gt="{}")'.format(field, value))
                elif operator == '<':
                    query.append('Q({}__lt="{}")'.format(field, value))
                else:
                    return None
        query_str = ' '.join(query)
        try:
            rules = RuleItem.objects.filter(eval(query_str))
        except Exception as e:
            print("Error in search_rules:", e)
            print("Query:", query_str)
            rules = None

        return rules


if __name__ == "__main__":
    pass